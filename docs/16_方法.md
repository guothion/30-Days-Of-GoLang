# 基本介绍
在某些情况下，我们需要声明（定义）方法。比如 Person 结构体：除了有一些字段外，Person 结构还有一些行为比如：说话、跑步...通过学习，还可以做算术题。
**这时候就要用到方法才能完成**。

Golang 中的**方法是作用在指定的数据类型上**的，（即：和指定的数据类型绑定），因此**自定义类型，都可以有方法**，不仅仅是struct。
```go
type A struct {
	Num int
}
func (a A) test() {
	fmt.Println(a.Num)
}
```
对上边的说明：
1. `func(a A) test() {}` 表示 A 结构体有一个方法，方法名为`test`
2. `(a A)`体现了 test 方法是和 A 类型绑定的

## 方法调用和传参机制
- 收集变量
- 调用方法，生成一个新的独立的空间，并且把传入的参数值拷贝到我们独立空间中
- **拷贝**一个调用方法的对象，比如`Person`

## 方法的注意事项和细节
1. 结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是只拷贝传递方式
2. 如果程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式传递处理
3. Golang 中的**方法作用在指定的数据类型上**的（即：和指定的数据类型绑定），因此**自定义类型，都可以有方法**，而不仅仅是struct，比如int,float32等都可以绑定方法
4. 方法的访问规则也是首字母大写可以挎包访问
5. 如果一个类型实现了 **String()** 这个方法，那么 fmt.Println 默认会调用这个变量的`string()`进行输出

## 方法和函数的区别
- 对于普通函数，接受者为值类型，不能将指针类型的数据传递过去，反之也是一样的。但是方法的话自己去获取对应的数据，不依赖传入。但是如果是方法就没有要求，怎么调用都可以。
```go
type Person {
    Name: string
}
func (p Person) test03() {
	p.Name = "jack"
	fmt.Println("test03()=",p.Name)
}
func main() {
	p := Person{"tom"}
	
	p.test03()     // 可以 
	(&p).test03()  // 也可以
}
```
也就是说我们只需要关注我们定义方法的时候用的是**指针**还是**值**，不用关注是什么调用的。


