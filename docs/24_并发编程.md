## 什么是并发
### 首先我们需要了解什么是进程？什么是线程？
> **进程**：进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。
>
> **线程**：线程是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
> 
> 一个进程可以创建和撤销多个线程。同一个进程中的多个线程可以并发执行。
### 并发和并行
> **并发**：多个程序在一个核的 CPU 上运行
> 
> **并行**：多线程序在多个核的 CPU 上运行
### 协程和线程
> **协程**：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级现成的调度也是自己实现的。
> 
> **线程**：一个线程上可以跑多个协程，协程是轻量级的线程。

## goroutine 
**goroutine**是由官方实现的超级“线程池”。每个`4~5KB`的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是 Go 高并发的根本原因。
**goroutine**奉行通过通信来共享内存，而不是共享内存来通信。

### 使用goroutine
Go 语言中使用goroutine 非常简单，只需要在调用函数的时候在前面加上`go`关键字，就可以为一个函数创建一个`goroutine`。

一个goroutine必定对应一个函数，可以创建多个goroutine去指向相同的函数。

### 启动单个goroutine
```go
func hello() {
	fmt.Println("Hello Goroutine!")
}
func main() {
	hello()
	fmt.Println("main goroutine done!")
}
```
这个示例中`hello`函数和下面的语句是串行的，执行的结果是打印完`Hello Goroutine!`后打印`main goroutine done!`。

接下来我们在调用`hello`函数前面加上关键字`go`，也就是启动一个`goroutine`去执行`hello`这个函数。

````go
func main() {
    go hello() // 启动另外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
}
````

这一次的执行结果只打印了`main goroutine done!`，并没有打印`Hello Goroutine!`。为什么呢？

当`main()`函数返回的时候该`goroutine`就结束了，所有在`main()`函数中启动的`goroutine`会一同结束，`main`函数所在的`goroutine`就像是权利的游戏中的夜王，其他的`goroutine`都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。

所以我们要想办法让`main`函数等一等`hello`函数，最简单粗暴的方式就是`time.Sleep`了。
```go
func main() {
    go hello() // 启动另外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
    time.Sleep(time.Second)
}
```
执行上面的代码你会发现，这一次先打印`main goroutine done!`，然后紧接着打印`Hello Goroutine!`。

首先为什么会先打印`main goroutine done!`是因为我们在创建新的`goroutine`的时候需要花费一些时间，而此时`main`函数所在的`goroutine`是继续执行的。

### 启动多个goroutine
在Go语言中实现并发就是这样简单，我们还可以启动多个`goroutine`。让我们再来一个例子： （这里使用了`sync.WaitGroup`来实现`goroutine`的同步）
```go
package main
import (
    "async"
)
var wg sync.WaitGroup

func hello(i int) {
	defer wg.Done()
	fmt.Println("Hello Goroutine!", i)
}

func main() {
	for i := 0; i < 10; i++ {
	    wg.Add(1) // 启动一个goroutine就等级 -1
		go hello(i)
    }
	wg.Wait()  // 等待所有等级的goroutine都结束
}
```

## runtime包

