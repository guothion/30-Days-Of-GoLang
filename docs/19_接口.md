## 什么是接口
**interface**类型可以定义一组方法，但是不需要实现，**并且 interface 不能包含任何变量**。到某个自定义类型（比如结构体 Phone）要使用的时候，再根据
具体情况把这些方法写出来（实现）。


## 基本语法
```go
type 接口名 interface {
	method1(参数列表) 返回值列表
	method2(参数列表) 返回值列表
	...
}

func (t 自定义类型) method1(参数列表) 返回值列表 {
	// 方法实现
}
func (t 自定义类型) method2(参数列表) 返回值列表 {
// 方法实现
}
...
```

golang 里边没有 `implement` 这样的关键字。别的语言中实现了哪个接口往往写成：
```typescript
interface Student {}
class Punic implements Student {}
```

## 应用场景
比如我们制造一款机器，放进机器的水果只要有三种特点，我们就可以将它变成饮料，或者新的产品。具体哪三个特点我们可以给出三种方法，只要输入的水果具有这三个方法，就可以。
比如我们造飞机，我们需要飞机有几个功能，如果做出来的产品符合这些功能，我们就可以将其运用到飞机场，投入运营。

## 注意
1. 接口本身不能创建实例，但是**可以指向一个实现了该接口的自定义类型变量**
2. 接口中所有的方法都没有方法体，即都是没有实现的方法。
3. Golang 中一个自定义类型需要将某个接口的所有方法都实现了，我们说这个自定义类型实现了该接口
4. 只要是自定义数据类型就可以实现接口，不仅仅是结构体类型
5. 我们如果实现的是结构体的指针类型方法（非结构体类型），就没有实现了该自定义接口
```go
type Usb interface {
	Start()
}
type Phone struct {}
func (p *Phone) Start() {}

func main() {
	var p Phone
	var usb Usb = p
	usb.Start() // 报错，因为我们上边是指针类型的方法，不是结构体类型
}
```
我们如果想用怎么办呢？
加一个 `&` 就可以了。
```go
type Usb interface {
	Start()
}
type Phone struct {}
func (p *Phone) Start() {}

func main() {
	var p Phone
	var usb Usb = &p // 加一个 & 就可以
	usb.Start() 
}
```
## 接口和继承
- 当A 结构体继承了 B 结构体，那么 A 结构体就继承了 B 结构体的字段和方法，并且可以直接使用
- 当A 结构体需要扩展功能，同时不去破坏继承关系，则可以去实现某个接口即可，因此我们可以认为：实现接口是对继承机制的补充。
- 实现接口可以看作是对继承的一种补充
- 接口和继承解决的问题不同
  - 继承主要价值在于解决代码的**复用性和可维护性**
  - 接口的价值主要在于**设计**，设计好各种规范，让其它自定义类型去实现这些方法
- 接口比继承更加灵活
- 接口在一定程度上实现代码解耦

## 多态
接口提现多态的两种形式
- 多态参数
在前面的 USB 接口案例，Usb usb ,即可以接收手机变量，有可以接收相机变量，就体现了 Usb 接口多态。
- 多态数组
演示一个案例 给 Usb 数组中，存放Phone结构体和 Camera 结构体变量
案例说明：

